
Tutorial
========

.. contents::

Some examples
~~~~~~~~~~~~~

The examples here are produced with... ``rstweaver``! It's literate literate
programming! That means you'll see a block of raw reST code, followed by the
rendered HTML it should produce. That block of course has embedded blocks of
code in it, which I have tried to distinguish using thinner lines. Hope you can
follow.

Let's introduce a block of Haskell code:

.. weaver:: new exec join

    .. haskell:: Main.hs
        
        main = do
            putStrLn "Hello... world."

That fed some content to the file but it didn't execute it or even compile it.
Had we wanted to execute it we could have written:

.. weaver:: new exec join

    .. haskell:: Main-2.hs exec
    
        main = do
            putStrLn "Hello... world."

A file can be built in multiple stages:

.. weaver:: new exec join

    .. haskell:: Stages.hs
    
        import Control.Monad
    
    .. haskell:: Stages.hs
    
        genNumbers :: [Int]
        genNumbers = do
            a <- [0, 1]
            b <- [0, 1]
            return $ a + b
    
    .. haskell:: Stages.hs exec
    
        main = do
            print genNumbers

The last stage included "``exec``", so the file was executed.

You can name the stages:

.. weaver:: new exec join

    .. haskell:: Named.hs
        :name: imports
        
        import Control.Monad

And then go back and edit them:

.. weaver:: new exec join

    .. haskell:: Named.hs redo
        :name: imports
        
        import Control.Monad
        import Control.Applicative

Or insert a stage after a named stage:

.. weaver:: new exec join

    .. haskell:: Named.hs
        :after: imports
        
        x = 5

Or at the beginning:

.. weaver:: new exec join

    .. haskell:: Named.hs
        :after: start
        
        {-# LANGUAGE DeriveDataTypeable #-}

You can restart a whole file:

.. weaver:: new exec join

    .. haskell:: Main.hs restart
        
        main = do
            putStrLn "Hello... world?"

You can test compiling without executing (this has no effect on later
commands):

.. weaver:: new exec join

    .. haskell: Main.hs done

You can run interactive commands that reference your file:

.. weaver:: new exec join

    .. ghci:: Main.hs
        
        :t main
 
You can add some code silently:

.. weaver:: new exec join

    .. haskell:: Main.hs noecho
        
        -- You can't see this comment ;)

You can print some code but not add it to any file:

.. weaver:: new exec join

    .. haskell:: noeval
    
        maine =
            a state

Error messages do not interrupt the execution: they will show up as error
messages in the resulting HTML. I like this because it lets you show what error
messages look like. You may or may not approve.

Registering the directives
~~~~~~~~~~~~~~~~~~~~~~~~~~

To register all languages included with ``rstweaver``, call

::
    
    rstweaver.register_all_languages()

And to register your own languages

::
    
    rstweaver.register_weaver_language(MyLanguage)

Sphinx
------

Add to your ``conf.py``:

::

    import rstweaver
    rstweaver.register_all_languages()

To get the necessary CSS, run::

    rstweave --print-css

And add it somewhere that Sphinx will include (such as at the end of
``default.css``)

Other languages
~~~~~~~~~~~~~~~

As of writing, ``rstweaver`` supports Haskell, C++, Python and reST. Adding
languages is suppose to be easy. The best way to see how is to look at the
examples in rstweaver/languages/. Some information is provided here too.

Adding languages
~~~~~~~~~~~~~~~~

See below for how to define a language. Once you have defined a language, you
will need to register its directives. This is a matter of calling

::
    
    rstweaver.register_weaver_language(MyLanguage)

sometime before you process your document.

Of course, if you're using the ``rstweave`` program that won't do you much
good. For ``rstweave`` to see the language, you need to add it to the
``rstweaver`` distribution.

Adding a language to ``rstweaver`` proper
-----------------------------------------

1. Add the code for you language in ``rstweaver/languages/``
2. Import it from ``rstweaver/languages/__init__.py`` and add it to the
   obvious list.

Now ``rstweave`` will recognize it. Yes this is a terrible system. I just
haven't gotten around to making a better one.

Defining languages
~~~~~~~~~~~~~~~~~~

To add a language you will want to extend ``rstweaver.WeaverLanguage``, and
override some methods.

``WeaverLanguage`` has many methods, but there are only a few that you have do
deal with to get something working.

Non-interactive directives
--------------------------

"Non-interactive" is what the ``haskell`` directive is in the examples above:
whole blocks of code are added to a file, then the file is executed in one go.

Here's a terribly terribly minimal implementation for Haskell:

::

    from rstweaver import WeaverLanguage
    from subprocess import Popen, PIPE

    class MinimalHaskell(WeaverLanguage):
        
        def __init__(self, **other_options):
            WeaverLanguage.__init__(self, {
                WeaverLanguage.noninteractive: 'minhaskell'
            },
            **other_options
            )
        
        def test_compile(self, path, wd):
            ghc = Popen(
                ['ghc', '-c', '-o', '/dev/null', path],
                stdout = PIPE,
                stderr = PIPE,
                cwd = wd
            )
            out, err = ghc.communicate()
            
            return err
        
        def run(self, path, wd):
            runghc = Popen(
                ['runghc', path],
                stdout = PIPE,
                stderr = PIPE,
                cwd = wd
            )
            
            out, err = runghc.communicate()
            
            return err + out
        
        def highlight_lang(self):
            return 'haskell'

Which could be used like

.. weaver:: new exec join

    .. minhaskell:: new exec
    
        main = do
            putStrLn "Yo"
            

The important parts are:

1. Telling ``WeaverLanguage`` you want a non-interactive directive,
   by adding an entry to the dictionary passed to __init__.
2. Implementing ``test_compile``, ``run``, and ``highlight_lang``.

Interactive directives
----------------------

Here's a similarly minimal implementation for interactive Haskell:

::

    from rstweaver import WeaverLanguage
    from subprocess import Popen, PIPE

    class MinimalGHCI(WeaverLanguage):
        
        def __init__(self, **other_options):
            WeaverLanguage.__init__(self, {
                WeaverLanguage.interactive:    'minghci'
            },
            **other_options
            )
        
        def run_interactive(self, lines, imports, wd):
            def do_line(line):
                command = ['ghc'] + imports + ['-e', line]
                
                ghci = Popen(
                    command,
                    stdout = PIPE,
                    stderr = PIPE,
                    cwd = wd
                )
                
                out, err = ghci.communicate()

                return err + out
            
            return [do_line(line) for line in lines]
        
        def highlight_lang(self):
            return 'haskell'

Which can be used like

.. weaver:: new exec join

    .. minghci::
        
        :t (:)

The steps are:

1. Telling WeaverLanguage to register an interactive directive.
2. Defining ``run_interactive`` and ``highlight_lang``
   
You might notice that this implementation has no "memory": one line of
interactive input has no effect on the next. That could be improved.

